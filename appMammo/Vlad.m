classdef Vlad < handle
    properties
        srcRegnDscrber;
        setting;
    end
    methods
        function this = Vlad...
                ( srcRegnDscrber, setting )
            this.srcRegnDscrber                     = srcRegnDscrber;
            this.setting.normalizeByScale           = true;
            this.setting.spatialPyramid             = '11';
            this.setting = setChanges...
                ( this.setting, setting, upper( mfilename ) );
        end
        function vlad = iid2desc( this, iid )
            [ rid2geo, rid2desc, imsize ] = ...
                this.srcRegnDscrber.iid2regdesc( iid, false );
            vlad = this.encodeSpVlad...
                ( rid2geo, rid2desc, imsize );
        end
        function vlad = im2desc( this, im )
            [ rid2geo, rid2desc, imsize ] = ...
                this.srcRegnDscrber.im2regdesc( im );
            vlad = this.encodeSpVlad...
                ( rid2geo, rid2desc, imsize );
        end
        function spVlad = encodeSpVlad...
                ( this, rid2geo, rid2desc, imsize )
            spatialPyramid              = this.setting.spatialPyramid;
            numLevel                    = length( spatialPyramid ) / 2;
            layouts                     = reshape...
                ( spatialPyramid, [ 2, numLevel ] );
            srid2level = cell( numLevel, 1 );
            subreg = cell( numLevel, 1 );
            for l = 1 : numLevel;
                layout = layouts( :, l );
                nr = str2double( layout( 1 ) );
                nc = str2double( layout( 2 ) );
                srid2level{ l } = cat...
                    ( 1, l * ones( nr * nc, 1 ) );
                subreg{ l } = this.ndiv2subregs( nr, nc );
            end; 
            subreg = cat( 2, subreg{ : } );
            numSubreg = size( subreg, 2 );
            srid2vlad = cell( numSubreg, 1 );
            for srid = 1 : numSubreg
                minR = subreg( 1, srid ) * ( imsize( 1 ) - 1 ) + 1;
                minC = subreg( 2, srid ) * ( imsize( 2 ) - 1 ) + 1;
                maxR = subreg( 3, srid ) * ( imsize( 1 ) - 1 ) + 1;
                maxC = subreg( 4, srid ) * ( imsize( 2 ) - 1 ) + 1;
                rid2center = ...
                    ( rid2geo( 1 : 2, : ) + rid2geo( 3 : 4, : ) ) / 2;
                rid2isroi = this.coor2isroi...
                    ( rid2center, minR, minC, maxR, maxC ); 
                roiGeos = rid2geo( :, rid2isroi );
                roiDescs = rid2desc( :, rid2isroi );
                vlad = this.descs2vlad...
                    ( roiDescs, roiGeos );
                srid2vlad{ srid } = vlad; 
            end
            spVlad = cat( 1, srid2vlad{ : } );
        end
        function vlad = descs2vlad...
                ( this, descs, geos )
            if this.setting.normalizeByScale
                scales = unique( geos( end, : ) )';
                sid2vlad = cell( size( scales ) );
                for sid = 1 : numel( scales )
                    roi = geos( end, : ) == scales( sid );
                    [ words, ~ ] = vl_kdtreequery( ...
                        this.srcRegnDscrber.visword.kdtree, ...
                        this.srcRegnDscrber.visword.words, ...
                        descs( :, roi ), ...
                        'MaxComparisons', 15);
                    assign = zeros( ...
                        this.srcRegnDscrber.settingDic.numVisword, ...
                        numel( words ), 'single' );
                    assign( ...
                        sub2ind( size( assign ), ...
                        double( words ), ...
                        1 : numel( words ) ) ) = 1 ;
                    svlad = vl_vlad( ...
                        descs( :, roi ), ...
                        this.srcRegnDscrber.visword.words, ...
                        assign, ...
                        'SquareRoot' );
                        % 'SquareRoot', ...
                        % 'NormalizeComponents' );
                    svlad = nmlzVecs( svlad, 'L2' );
                    sid2vlad{ sid } = svlad;
                end
                vlad = mean( cat( 2, sid2vlad{ : } ), 2 );
            else
                [ words, ~ ] = vl_kdtreequery( ...
                        this.srcRegnDscrber.visword.kdtree, ...
                        this.srcRegnDscrber.visword.words, ...
                        descs, ...
                        'MaxComparisons', 15);
                    assign = zeros( ...
                        this.srcRegnDscrber.settingDic.numVisword, ...
                        numel( words ), 'single' );
                    assign( ...
                        sub2ind( size( assign ), ...
                        double( words ), ...
                        1 : numel( words ) ) ) = 1 ;
                    vlad = vl_vlad( ...
                        descs, ...
                        this.srcRegnDscrber.visword.words, ...
                        assign, ...
                        'SquareRoot' );
                        % 'SquareRoot', ...
                        % 'NormalizeComponents' );
            end
            vlad = nmlzVecs( vlad, 'L2' );
        end
        % Functions for object identification.
        function name = getName( this )
            name = sprintf( 'VD_%s_OF_%s', ...
                this.setting.changes, ...
                this.srcRegnDscrber.getName );
            name( strfind( name, '__' ) ) = '';
            if name( end ) == '_', name( end ) = ''; end;
        end
    end
    methods( Static )
        function subreg = ndiv2subregs...
                ( nrowDiv, ncolDiv )
            m = nrowDiv;
            n = ncolDiv;
            [ x, y ] = meshgrid...
                ( linspace( 0, 1, n + 1 ), ...
                linspace( 0, 1, m + 1 ) );
            x1 = x( 1 : end - 1, 1 : end - 1 );
            y1 = y( 1 : end - 1, 1 : end - 1 );
            x2 = x( 2 : end, 2 : end );
            y2 = y( 2 : end, 2 : end );
            subreg = [ y1( : )'; x1( : )'; ...
                       y2( : )'; x2( : )'; ];
        end
        function isroi = coor2isroi...
                ( idx2rc, minR, minC, maxR, maxC )
            isroi = ...
                minR <= idx2rc( 1, : ) & ...
                idx2rc( 1, : ) <= maxR  & ...
                minC <= idx2rc( 2, : ) & ...
                idx2rc( 2, : ) <= maxC ;
        end
    end
end

